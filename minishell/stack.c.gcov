        -:    0:Source:/home/anthony/Documents/Classes/Cryptography/Structures/stack.c
        -:    0:Graph:./obj/stack.gcno
        -:    0:Data:./obj/stack.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:// Anthony Islas
        -:    2:// Data Structure: Stack (FIFO)
        -:    3:// Date Written: 12 Oct 2015
        -:    4:// Last Revised: 12 Oct 2015
        -:    5:// This c file will be used for the implementation of a stack using a circular linked list 
        -:    6:
        -:    7:#include "stack.h"
        -:    8:
        -:    9://Make an init function so user can easily use
function stack_init called 63 returned 100% blocks executed 100%
       63:   10:bool stack_init(STACK_t* userS)
        -:   11:{
        -:   12:  // Set function pointers are initialize head
       63:   13:  userS->head = NULL;
       63:   14:  userS->size = 0;
       63:   15:  return true;
        -:   16:}
        -:   17:
        -:   18://***********************************************
        -:   19://
        -:   20:// isEmpty predicate
        -:   21://
        -:   22://***********************************************
        -:   23:
function isStackEmpty called 0 returned 0% blocks executed 0%
    #####:   24:bool isStackEmpty(STACK_t* userS)
        -:   25:{
    #####:   26:  if(userS->head == NULL) return true;
branch  0 never executed
branch  1 never executed
    #####:   27:  else return false;
        -:   28:}
        -:   29:
        -:   30:
        -:   31:
        -:   32://***********************************************
        -:   33://
        -:   34:// print queue
        -:   35://
        -:   36://***********************************************
function printStack called 0 returned 0% blocks executed 0%
    #####:   37:void printStack(STACK_t* userS)
        -:   38:{
        -:   39:// Find head
    #####:   40:  itemS_t **head = &userS->head;
        -:   41:  
        -:   42:  // Go into loop if head does not point to null
    #####:   43:  if((*head) == NULL)
branch  0 never executed
branch  1 never executed
        -:   44:  {
        -:   45:    // List is empty
    #####:   46:    printf("Stack is empty\n");
call    0 never executed
    #####:   47:    return;
        -:   48:  }
        -:   49:  // else
    #####:   50:  itemS_t* trvPtr = (*head);
    #####:   51:  printf("\nStack is: %d -> ", INT_CAST (trvPtr->keyValue));
call    0 never executed
        -:   52:
        -:   53:  // Continue to traverse list
    #####:   54:  trvPtr = trvPtr->next;
        -:   55:  
    #####:   56:  while(trvPtr != NULL)
branch  0 never executed
branch  1 never executed
        -:   57:  {
        -:   58:    // Print
    #####:   59:    printf("%d -> ", INT_CAST (trvPtr->keyValue));
call    0 never executed
        -:   60:    
        -:   61:    // Continue to traverse list
    #####:   62:    trvPtr = trvPtr->next;
        -:   63:   
        -:   64:  }
    #####:   65:  printf("\n");
call    0 never executed
    #####:   66:  return;
        -:   67:}
        -:   68:
        -:   69:// *NOTE: itemList** (pointer to pointer) is used in insertion and deletion function
        -:   70://        because the functions exist outside of the main loop, and for special cases of moving 
        -:   71://        the head of the list we need the actual pointer, not a copy.
        -:   72:
        -:   73://***********************************************
        -:   74://
        -:   75:// insertion function
        -:   76://
        -:   77://***********************************************
function push called 307 returned 100% blocks executed 100%
      307:   78:void push(STACK_t* userS, void* keyToInsert)
        -:   79:{
        -:   80:  // Find head
      307:   81:  itemS_t **head = &userS->head;
        -:   82:  
        -:   83:  // Create new item
      307:   84:  itemS_t* temp = malloc(sizeof(itemS_t));
      307:   85:  temp->keyValue = keyToInsert;
        -:   86:  
      307:   87:  userS->size++;
        -:   88:  
        -:   89:  // Reassign pushback
      307:   90:  temp->next = *head;
      307:   91:  (*head) = temp;
      307:   92:  return;
        -:   93:  
        -:   94:}
        -:   95:
        -:   96://***********************************************
        -:   97://
        -:   98:// removal
        -:   99://
        -:  100://***********************************************
        -:  101:
function pop called 338 returned 100% blocks executed 100%
      338:  102:itemS_t* pop(STACK_t* userS)
        -:  103:{
        -:  104:  // Find head
      338:  105:  itemS_t **head = &userS->head;
        -:  106:  
      338:  107:  itemS_t* rmvPtr = NULL;
        -:  108:  
        -:  109:  // FIRST check if list is empty
      338:  110:  if((*head) == NULL)
branch  0 taken 15% (fallthrough)
branch  1 taken 85%
        -:  111:  {
        -:  112:    // List is already empty
        -:  113:#ifdef DEBUG
        -:  114:    printf("Stack empty.\n");
        -:  115:#endif
       50:  116:    return NULL; 
        -:  117:  }
        -:  118:  // else
        -:  119:  // Remove from list
      288:  120:  rmvPtr = (*head);
      288:  121:  (*head) = (*head)->next;
        -:  122:  
      288:  123:  userS->size--;
        -:  124:  
        -:  125:  
        -:  126:  // return the value to main
      288:  127:  return rmvPtr;
        -:  128:
        -:  129:}
        -:  130:
function clearStack called 3 returned 100% blocks executed 100%
        3:  131:void clearStack(STACK_t* userS, bool localKeyValue)
        -:  132:{
        -:  133:  // Find head
        3:  134:  itemS_t **head = &userS->head;
        -:  135:  
        3:  136:  itemS_t* rmvPtr = NULL;
        -:  137:  
       25:  138:  while((*head) != NULL)
branch  0 taken 86%
branch  1 taken 14% (fallthrough)
        -:  139:  {
        -:  140:    // Remove from list
       19:  141:    rmvPtr = (*head);
        -:  142:    // return the memory to OS
       19:  143:    if(!localKeyValue) free(rmvPtr->keyValue);
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
       19:  144:    free(rmvPtr);
        -:  145:    
       19:  146:    (*head) = (*head)->next;
        -:  147:    
        -:  148:  }
        -:  149:  
        -:  150:  // Check if list is empty
        3:  151:  if((*head) == NULL)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  152:  {
        -:  153:    // List is already empty
        -:  154:    //printf("Stack empty.\n"); 
        3:  155:    userS->size = 0;
        -:  156:  }
        3:  157:}
