        -:    0:Source:/home/christian/Documents/GitHub/Cryptography/login_module/login.c
        -:    0:Graph:./obj/login.gcno
        -:    0:Data:./obj/login.gcda
        -:    0:Runs:13
        -:    0:Programs:1
        -:    1:// Anthony Islas
        -:    2:// Date Written: 12 Dec 2014
        -:    3:// Last Revised:  6 Sept 2015
        -:    4:// DESCRIPTION:	This will be the base for logging into a shell that will
        -:    5:// not only exexcute standard UNIX commands, but act as a front end
        -:    6:// to enable encryption of files
        -:    7:
        -:    8:#include <stdio.h>
        -:    9:#include <stdlib.h>
        -:   10:#include <string.h>
        -:   11:#include <stdbool.h>
        -:   12:#include <pwd.h>
        -:   13:#include <time.h>
        -:   14:#include <limits.h>
        -:   15:#include <unistd.h>
        -:   16:
        -:   17:#define _GNU_SOURCE   
        -:   18:#include <crypt.h>
        -:   19:
        -:   20:#include "login.h"
        -:   21:
        -:   22:// Global
        -:   23:static int current_user = -1, max_users = 0;
        -:   24:static char passphraseFile[PATH_MAX];
        -:   25:static char curName[MAX_NAME] = "default";
        -:   26:
function loginProtocol called 19 returned 100% blocks executed 70%
       19:   27:bool loginProtocol(char option)
        -:   28:{
        -:   29:  // Initialization
       19:   30:  bool enter_sp = false;
        -:   31:  users_t session_users[MAX_USERS];
        -:   32:	
        -:   33:	FILE* passphrase;
        -:   34:  
       19:   35:	if((passphrase = fopen(passphraseFile, "r+")) == NULL)
call    0 returned 100%
branch  1 taken 5% (fallthrough)
branch  2 taken 95%
        -:   36:	{
        1:   37:		printf("File not found. Creating new file\n");
call    0 returned 100%
        1:   38:		if((passphrase = fopen(passphraseFile, "w+")) == NULL)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   39:		{
    #####:   40:			printf("Could not create file\n");
call    0 never executed
    #####:   41:			return false;
        -:   42:		}
        1:   43:		if(option != 'n') 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   44:		{
    #####:   45:		  option = 'n';
    #####:   46:		  printf("Defaulting to make new user...\n");
call    0 never executed
        -:   47:		}
        -:   48:	}
        -:   49:  
        -:   50:  // Defaults for users set first
      209:   51:  for(int iterator = MAX_USERS; iterator > 0; iterator--)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   52:  {
      190:   53:    INIT_USER(session_users[iterator - 1]);
        -:   54:  }
        -:   55:  
        -:   56:	// Read in users from file
       19:   57:	PERROR_NUM_BOOL(fseek(passphrase, 0, SEEK_SET));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
       19:   58:	max_users = fread((unsigned char*) session_users, sizeof(unsigned char), sizeof(users_t)*MAX_USERS, passphrase) / (sizeof(users_t));
call    0 returned 100%
       19:   59:	if(ferror(passphrase)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   60:		printf("loginProtocol: error reading passphrase file\n");
call    0 never executed
    #####:   61:		return false;
        -:   62:	}
       19:   63:	PERROR_NUM_BOOL(fclose(passphrase));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:   64:	// Makes sure users are only in memory
        -:   65:    
       19:   66:  switch(option)
branch  0 taken 37%
branch  1 taken 47%
branch  2 taken 16%
branch  3 taken 0%
        -:   67:  {
        -:   68:    case 'l':
        7:   69:      enter_sp = login(session_users);
call    0 returned 100%
        7:   70:      break;
        -:   71:    case 'n':
        9:   72:      enter_sp = newAccount(session_users);
call    0 returned 100%
        9:   73:      break;
        -:   74:    case 'd':
        3:   75:      enter_sp = deleteUser(session_users);
call    0 returned 100%
        3:   76:      break;
        -:   77:    default:
    #####:   78:      enter_sp = false;
    #####:   79:      printf("Oops. Looks like the option you requested wasn't found. Try again.\n");
call    0 never executed
    #####:   80:      break;
        -:   81:  }
        -:   82:
       19:   83:  return enter_sp;  
        -:   84:}
        -:   85:
        -:   86://************************************************************************
        -:   87://
        -:   88:// Taken directly from minishell.c - emulate reading of CLI
        -:   89:// 
        -:   90://************************************************************************
        -:   91:
function readInput called 53 returned 100% blocks executed 80%
       53:   92:void readInput(char *buffer) 
        -:   93:{
        -:   94:    // original dangerous stdio call - can over-run buffer, see man gets
        -:   95:    // gets(buffer); 
        -:   96:
        -:   97:  
        -:   98:    // suggested safer replacement call - can't go beyond length provided,
        -:   99:    // but we must strip off the line feed included in the buffer unlike gets
        -:  100:    // 
      106:  101:    ERROR_PTR_VOID(fgets(buffer, MAX_NAME, stdin));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  102:
       53:  103:    buffer[strlen(buffer) - 1] = '\0';  // overwrite the line feed with null term
        -:  104:}
        -:  105:
        -:  106://************************************************************************
        -:  107://
        -:  108:// Modified readInput to allow getpass to be used instead of stdin
        -:  109:// 
        -:  110://************************************************************************
        -:  111:
function readPasswd called 18 returned 100% blocks executed 93%
       18:  112:void readPasswd(char *buffer, const char *salt, char *username) 
        -:  113:{
       18:  114:  char passwdPrompt[] = "Password [4-8 chars]: ";
       18:  115:  char* ps_buffer = getpass(passwdPrompt);
call    0 returned 100%
       18:  116:  int strLen = strlen(ps_buffer);
       18:  117:  if(strLen < MAX_PASSWD - 5 && strLen >= MIN_INPUT  && (strcmp(username, ps_buffer) != 0))
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
branch  2 taken 88% (fallthrough)
branch  3 taken 13%
branch  4 taken 86% (fallthrough)
branch  5 taken 14%
        -:  118:  {
       12:  119:    ps_buffer = crypt(ps_buffer, salt);
call    0 returned 100%
       12:  120:    if(ps_buffer == NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  121:    {
    #####:  122:      buffer[0] = '\0';
    #####:  123:      printf("Error in crypt\n");
call    0 never executed
        -:  124:    }
        -:  125:      
       12:  126:    buffer[strlen(ps_buffer)-1] = '\0';  // overwrite the line feed with null term
       12:  127:    strcpy(buffer, ps_buffer);
        -:  128:  }
        6:  129:  else if(strLen >= MAX_PASSWD - 5)
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        -:  130:  {
        2:  131:    buffer[0] = '\0';
        2:  132:    printf("Error: Password too long\n"); 
call    0 returned 100%
        -:  133:  }
        4:  134:  else if(strLen < MIN_INPUT)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  135:  {
        2:  136:    buffer[0] = '\0';
        2:  137:    printf("Error: Password too short\n"); 
call    0 returned 100%
        -:  138:  }
        -:  139:  else 
        -:  140:  {
        2:  141:    buffer[0] = '\0';
        2:  142:    printf("Error: Cannot use username as password\n");
call    0 returned 100%
        -:  143:  }
       18:  144:}
        -:  145:
        -:  146://************************************************************************
        -:  147://
        -:  148:// Protocol for login
        -:  149:// 
        -:  150://************************************************************************
        -:  151:
function login called 7 returned 100% blocks executed 93%
        7:  152:bool login(users_t* cur_list)
        -:  153:{
        -:  154:  // Initialize
        -:  155:  char cl_buffer[MAX_PASSWD];
        -:  156:  
        -:  157:  // Prompt
        7:  158:  printf("Enter username: ");
call    0 returned 100%
        7:  159:  readInput(cl_buffer);
call    0 returned 100%
        -:  160:  
        -:  161:  // Search first for username
       17:  162:  for(int iterator = MAX_USERS; iterator > 0; iterator--)
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  163:  {
        -:  164:    // If successful ask for password
       16:  165:    if(strcmp(cur_list[MAX_USERS - iterator].user_name,cl_buffer) == 0)
branch  0 taken 38% (fallthrough)
branch  1 taken 63%
        -:  166:    {
        -:  167:      // prompt 
        -:  168:
        6:  169:      readPasswd(cl_buffer, cur_list[MAX_USERS - iterator].user_passwd, cur_list[MAX_USERS - iterator].user_name);
call    0 returned 100%
        -:  170:      // Check password to user account
        6:  171:      if(strcmp(cur_list[MAX_USERS - iterator].user_passwd,cl_buffer) == 0) 
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        -:  172:      {
        4:  173:        current_user = MAX_USERS - iterator;
        4:  174:        printf("Logged in as: %s", cur_list[MAX_USERS - iterator].user_name);
call    0 returned 100%
        4:  175:        strcpy(curName, cur_list[MAX_USERS - iterator].user_name);
        4:  176:        current_user == 0 ? printf(" [ADMIN]\n") : printf("\n");
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 never executed
        4:  177:        return true;
        -:  178:      }
        -:  179:      else
        -:  180:      {
        -:  181:        // Wrong password
        2:  182:        int err_login = 0;
        9:  183:        while(err_login < TRIES)
branch  0 taken 86%
branch  1 taken 14% (fallthrough)
        -:  184:        {
        -:  185:          // Loop allows for a retry 3 times
        6:  186:          printf("Sorry, try again.\n");
call    0 returned 100%
        6:  187:          readPasswd(cl_buffer, cur_list[MAX_USERS - iterator].user_passwd, cur_list[MAX_USERS - iterator].user_name);
call    0 returned 100%
        -:  188:          // Auto exit if correct
        6:  189:          if(strcmp(cur_list[MAX_USERS - iterator].user_passwd,cl_buffer) == 0)
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
        -:  190:          {
        1:  191:            current_user = MAX_USERS - iterator;
        1:  192:            printf("Logged in as: %s", cur_list[MAX_USERS - iterator].user_name);
call    0 returned 100%
        1:  193:            strcpy(curName, cur_list[MAX_USERS - iterator].user_name);
        1:  194:            current_user == 0 ? printf(" [ADMIN]\n") : printf("\n");
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 never executed
        1:  195:            return true;
        -:  196:          }
        5:  197:          err_login++;
        -:  198:        }
        -:  199:        // If not exited by now, return false - failed login
        1:  200:        printf("Error: Login fail.\n");
call    0 returned 100%
        1:  201:        return false;
        -:  202:      }
        -:  203:    }
        -:  204:    // Continue through list
        -:  205:  } // End search
        -:  206:  // Search unsuccessful
        1:  207:  printf("Error: Oops. Username not found. Login fail.\n");
call    0 returned 100%
        1:  208:  return false;
        -:  209:}
        -:  210:
        -:  211://************************************************************************
        -:  212://
        -:  213:// Protocol for creating a new account (currently just for session
        -:  214://
        -:  215://************************************************************************
        -:  216:
function newAccount called 9 returned 100% blocks executed 68%
        9:  217:bool newAccount(users_t* cur_list)
        -:  218:{
        -:  219:  //
        -:  220:  // Create new session account
        -:  221:  //
        -:  222:  
        -:  223:  // Initialize
        -:  224:  char cl_buffer[MAX_NAME];
        9:  225:  int temp_user = current_user;
        -:  226:	
        -:  227:	FILE* passphrase;
        9:  228:	if((passphrase = fopen(passphraseFile, "r+")) == NULL)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  229:	{
    #####:  230:		printf("File not found.\n");
call    0 never executed
    #####:  231:		return false;
        -:  232:	}
        -:  233:	// Makes sure users are only in memory
        -:  234:  
        -:  235:  // Search first for username spot available
       17:  236:  for(int iterator = MAX_USERS; iterator > 0; iterator--)
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
        -:  237:  {
        -:  238:    // If successful create account
       17:  239:    if(strcmp(cur_list[MAX_USERS - iterator].user_name, DEF_CHAR) == 0)
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
        -:  240:    {
        9:  241:      current_user = MAX_USERS - iterator;
        9:  242:      break;
        -:  243:    }
        -:  244:  } // search end
        -:  245:  // If successful, current_user should have changed
        9:  246:  if(temp_user == current_user)  // No available spot
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  247:  {
    #####:  248:    printf("Error: No spot available to create account. Please contact:\n\tAdmin: USER[0] to get account\n");
call    0 never executed
        -:  249:    // TODO Implement admin priveleges and deletion of accounts
    #####:  250:    PERROR_NUM_BOOL(fclose(passphrase));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  251:    return false;
        -:  252:  }
        -:  253:  
        -:  254:  // ELSE make account
        9:  255:  printf("Creating a new Account for USER[%d]:\n", current_user);
call    0 returned 100%
        -:  256:  // Prompt
        -:  257:  
        9:  258:  printf("Username[%d-%d chars]: ", MIN_INPUT, MAX_NAME - 1);
call    0 returned 100%
        9:  259:  readInput(cl_buffer);
call    0 returned 100%
        9:  260:  printf("\tUsername: %s\n", cl_buffer);
call    0 returned 100%
        9:  261:  int nameSize = strlen(cl_buffer);
        9:  262:  if((nameSize < MAX_NAME - 1) && nameSize >= MIN_INPUT)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 78% (fallthrough)
branch  3 taken 22%
        -:  263:  {
        -:  264:    // Search if username already taken
       67:  265:    for(int iterator = MAX_USERS; iterator > 0; iterator--)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:  266:    {
        -:  267:      // If successful create account
       61:  268:      if(strcmp(cur_list[MAX_USERS - iterator].user_name, cl_buffer) == 0)
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
        -:  269:      {
        1:  270:        printf("Error: Username not available\n");
call    0 returned 100%
        1:  271:        current_user = temp_user;
        1:  272:        PERROR_NUM_BOOL(fclose(passphrase));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        1:  273:        return false;
        -:  274:      }
        -:  275:    } // search end
        6:  276:    strcpy(cur_list[current_user].user_name, cl_buffer);
        6:  277:    strcpy(curName, cur_list[current_user].user_name);
        -:  278:  }
        2:  279:  else if(nameSize >= MAX_NAME)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  280:  {
    #####:  281:    printf("Error: Username too long\n");
call    0 never executed
    #####:  282:    current_user = temp_user;
    #####:  283:    PERROR_NUM_BOOL(fclose(passphrase));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  284:	current_user = temp_user;
    #####:  285:    return false;
        -:  286:  }
        2:  287:  else if(nameSize < MIN_INPUT)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  288:  {
        2:  289:    printf("Error: Username too short\n");
call    0 returned 100%
        2:  290:    current_user = temp_user;
        2:  291:    PERROR_NUM_BOOL(fclose(passphrase));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        2:  292:	current_user = temp_user;
        2:  293:    return false;
        -:  294:  }
        -:  295:  
        -:  296:  // Set password
        -:  297:  // Seed rand with user's first letter and its length
        -:  298:  // then assign salt
        6:  299:  srand(((unsigned int) cur_list[current_user].user_name[0] + strlen(cur_list[current_user].user_name)));
call    0 returned 100%
        6:  300:  const char salt[3] = {rand() % 26 + ASCII_A, rand() % 26 + ASCII_A, '\0'};
call    0 returned 100%
call    1 returned 100%
        6:  301:  readPasswd(cl_buffer, salt, cur_list[current_user].user_name);
call    0 returned 100%
        -:  302:  
        6:  303:  if(cl_buffer[0] != '\0')
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  304:  {
        3:  305:    strcpy(cur_list[current_user].user_passwd, cl_buffer);
        3:  306:		cur_list[current_user].user_id = current_user;
        -:  307:		
        -:  308:		// Update PASSPHRASE file
        3:  309:		PERROR_NUM_BOOL(fseek(passphrase, 0, SEEK_SET));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        3:  310:		fwrite((unsigned char*) cur_list, sizeof(unsigned char), sizeof(users_t)*(current_user + 1), passphrase);
call    0 returned 100%
        3:  311:    PERROR_NUM_BOOL(fclose(passphrase));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        3:  312:    printf("Logged in as: %s", cur_list[current_user].user_name);
call    0 returned 100%
        3:  313:    current_user == 0 ? printf(" [ADMIN]\n") : printf("\n");
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
call    2 returned 100%
call    3 returned 100%
        -:  314:    // Makes sure users are only in memory
        -:  315:		
        3:  316:		return true;
        -:  317:  }
        -:  318:  else 
        -:  319:  {
        3:  320:    printf("Error: Could not create user. Password error in length or same as username\n");
call    0 returned 100%
        3:  321:    INIT_USER(cur_list[current_user]);
        3:  322:    current_user = temp_user;
        3:  323:    PERROR_NUM_BOOL(fclose(passphrase));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        3:  324:		return false;
        -:  325:  }
        -:  326:}
        -:  327:
        -:  328:
        -:  329://************************************************************************
        -:  330://
        -:  331:// Protocol for delete user
        -:  332:// 
        -:  333://************************************************************************
        -:  334:// Note: Must be admin USER[0] to use this option!
function deleteUser called 3 returned 100% blocks executed 55%
        3:  335:bool deleteUser(users_t* cur_list)
        -:  336:{ 
        -:  337:  char cl_buffer[MAX_NAME];
        3:  338:  if(current_user >= 1)
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        -:  339:  {
        1:  340:    printf("Delete account? [Yn]: ");
call    0 returned 100%
        1:  341:    readInput(cl_buffer);
call    0 returned 100%
        1:  342:    if(cl_buffer[0] == 'Y' || cl_buffer[0] == 'y')
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  343:    {
    #####:  344:      INIT_USER(cur_list[current_user]); 
        -:  345:
        -:  346:      // Update passphrase file
        -:  347:      FILE* passphrase;
    #####:  348:      if((passphrase = fopen(passphraseFile, "r+")) == NULL)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  349:      {
    #####:  350:        printf("File not found.\n");
call    0 never executed
    #####:  351:        return false;
        -:  352:      }
    #####:  353:      PERROR_NUM_BOOL(fseek(passphrase, 0, SEEK_SET));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  354:      fwrite((unsigned char*) cur_list, sizeof(unsigned char), sizeof(users_t)*max_users, passphrase);
call    0 never executed
    #####:  355:      PERROR_NUM_BOOL(fclose(passphrase));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  356:
    #####:  357:      printf("Deleted USER[%d] account.\n", current_user);
call    0 never executed
    #####:  358:      current_user = -1;
    #####:  359:      return true;
        -:  360:    }
        1:  361:    return false;
        -:  362:  }
        2:  363:  else if(current_user == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  364:  {
        -:  365:    // Admin user
        2:  366:    printf("Enter username: ");
call    0 returned 100%
        2:  367:    readInput(cl_buffer);
call    0 returned 100%
        -:  368:
        -:  369:    // Stolen from login protocol
        -:  370:    // Search first for username
       13:  371:    for(int iterator = MAX_USERS; iterator > 0; iterator--)
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
        -:  372:    {
        -:  373:      // If successful verify deletion and write out
       12:  374:      if(strcmp(cur_list[MAX_USERS - iterator].user_name,cl_buffer) == 0)
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
        -:  375:      {
        1:  376:        printf("Delete user ""%s""? [Yn]: ", cur_list[MAX_USERS - iterator].user_name);
call    0 returned 100%
        1:  377:        readInput(cl_buffer);
call    0 returned 100%
        -:  378:        // Assume everything else is N
        1:  379:        if(cl_buffer[0] == 'Y' || cl_buffer[0] == 'y')
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        -:  380:        {
        1:  381:          INIT_USER(cur_list[MAX_USERS - iterator]); 
        -:  382:
        -:  383:          // Update passphrase file
        -:  384:          FILE* passphrase;
        1:  385:          if((passphrase = fopen(passphraseFile, "r+")) == NULL)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  386:          {
    #####:  387:            printf("File not found.\n");
call    0 never executed
    #####:  388:            return false;
        -:  389:          }
        1:  390:          PERROR_NUM_BOOL(fseek(passphrase, 0, SEEK_SET));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        1:  391:          fwrite((unsigned char*) cur_list, sizeof(unsigned char), sizeof(users_t)*max_users, passphrase);
call    0 returned 100%
        1:  392:          PERROR_NUM_BOOL(fclose(passphrase));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  393:
        -:  394:          // If admin deleted self
        1:  395:          if((MAX_USERS - iterator) == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  396:          {
    #####:  397:            current_user = -1;
    #####:  398:            printf("Logged admin out\n");
call    0 never executed
        -:  399:          }
        -:  400:
        1:  401:          printf("Deleted USER[%d] account.\n", MAX_USERS - iterator);
call    0 returned 100%
        1:  402:          return true;
        -:  403:        }
    #####:  404:        return false;
        -:  405:      }
        -:  406:      // Continue through list
        -:  407:    } // End search
        -:  408:    // Search unsuccessful
        1:  409:    printf("Error: Username not found. Delete fail.\n");
call    0 returned 100%
        1:  410:    return false;
        -:  411:  }
    #####:  412:  return false;
        -:  413:}
        -:  414:
        -:  415:
        -:  416://************************************************************************
        -:  417://
        -:  418:// Accessors
        -:  419:// 
        -:  420://************************************************************************
function loginGetUsername called 0 returned 0% blocks executed 0%
    #####:  421:char* loginGetUsername(void)
        -:  422:{
    #####:  423:  return curName;
        -:  424:}
        -:  425:
        -:  426://************************************************************************
        -:  427://
        -:  428:// Initilize the module, fix bug where passphrase file was dependent on 
        -:  429:// working directory of program
        -:  430://
        -:  431://************************************************************************
function LoginModuleInit called 13 returned 100% blocks executed 73%
       13:  432:bool LoginModuleInit(void)
        -:  433:{
       13:  434:  uid_t uid = geteuid();
call    0 returned 100%
       13:  435:  errno = 0;
call    0 returned 100%
        -:  436:  
       13:  437:  struct passwd *pw = getpwuid(uid);
call    0 returned 100%
        -:  438:  
        -:  439:  // Check if errno has changed
       13:  440:  PERROR_NUM_BOOL((errno != 0 ? -1 : 0));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
       13:  441:  if (pw)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  442:  {
       13:  443:    sprintf(passphraseFile, "/home/%s/%s", pw->pw_name, PASSPHRASE);
       13:  444:    return true;
        -:  445:  }
    #####:  446:  else return false;
        -:  447:}
        -:  448:
function loginGetCurUser called 1 returned 100% blocks executed 100%
        1:  449:int loginGetCurUser(void)
        -:  450:{
        1:  451:  return current_user; 
        -:  452:}
        -:  453:
function loginSetCurUser called 1 returned 100% blocks executed 100%
        1:  454:void loginSetCurUser(int newCurUser)
        -:  455:{
        1:  456:  current_user = newCurUser; 
        1:  457:}
