        -:    0:Source:/home/anthony/Documents/Classes/Cryptography/Structures/queue.c
        -:    0:Graph:./obj/queue.gcno
        -:    0:Data:./obj/queue.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Anthony Islas
        -:    2:// Data Structure: Queue (LIFO)
        -:    3:// Date Written: 8 Oct 2015
        -:    4:// Last Revised: 12 Oct 2015
        -:    5:// This c file will be used for the implementation of a queue using a circular linked list 
        -:    6:
        -:    7:#include "queue.h"
        -:    8:
        -:    9://Make an init function so user can easily use
function queue_init called 10 returned 100% blocks executed 100%
       10:   10:bool queue_init(QUEUE_t* userQ)
        -:   11:{
        -:   12:  // Set function pointers are initialize head
       10:   13:  userQ->head = NULL;
       10:   14:  userQ->size = 0;
       10:   15:  return true;
        -:   16:}
        -:   17:
        -:   18://***********************************************
        -:   19://
        -:   20:// isEmpty predicate
        -:   21://
        -:   22://***********************************************
        -:   23:
function isQueueEmpty called 0 returned 0% blocks executed 0%
    #####:   24:bool isQueueEmpty(QUEUE_t* userQ)
        -:   25:{
    #####:   26:  if(userQ->head == NULL) return true;
branch  0 never executed
branch  1 never executed
    #####:   27:  else return false;
        -:   28:}
        -:   29:
        -:   30://***********************************************
        -:   31://
        -:   32:// print queue
        -:   33://
        -:   34://***********************************************
function printQueue called 0 returned 0% blocks executed 0%
    #####:   35:void printQueue(QUEUE_t* userQ)
        -:   36:{
        -:   37:// Find head
    #####:   38:  itemQ_t **head = &userQ->head;
        -:   39:  
        -:   40:  // Go into loop if head does not point to null
    #####:   41:  if((*head) == NULL)
branch  0 never executed
branch  1 never executed
        -:   42:  {
        -:   43:    // List is empty
    #####:   44:    printf("Queue is empty\n");
call    0 never executed
    #####:   45:    return;
        -:   46:  }
        -:   47:  // else
    #####:   48:  itemQ_t* trvPtr = (*head)->next;
    #####:   49:  printf(" %d", CHAR_CAST (trvPtr->keyValue));
call    0 never executed
        -:   50:
        -:   51:  
    #####:   52:  while(trvPtr != (*head))
branch  0 never executed
branch  1 never executed
        -:   53:  {
        -:   54:    // Continue to traverse list
    #####:   55:    trvPtr = trvPtr->next;
    #####:   56:    printf(" %d", CHAR_CAST (trvPtr->keyValue));
call    0 never executed
        -:   57:   
        -:   58:  }
    #####:   59:  printf("\n");
call    0 never executed
    #####:   60:  return;
        -:   61:}
        -:   62:
        -:   63:// *NOTE: itemList** (pointer to pointer) is used in insertion and deletion function
        -:   64://        because the functions exist outside of the main loop, and for special cases of moving 
        -:   65://        the head of the list we need the actual pointer, not a copy.
        -:   66:
        -:   67://***********************************************
        -:   68://
        -:   69:// insertion function
        -:   70://
        -:   71://***********************************************
function insertQueue called 43125 returned 100% blocks executed 100%
    43125:   72:void insertQueue(QUEUE_t* userQ, void* keyToInsert)
        -:   73:{
        -:   74:  // Find head
    43125:   75:  itemQ_t **head = &userQ->head;
        -:   76:  
        -:   77:  // Create new item
    43125:   78:  itemQ_t* temp = malloc(sizeof(itemQ_t));
    43125:   79:  temp->keyValue = keyToInsert;
        -:   80:  
    43125:   81:  userQ->size++;
        -:   82:
        -:   83:  // FIRST check the first element
    43125:   84:  if((*head) == NULL)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:   85:  {
        -:   86:    // Take care of special case for first item
       20:   87:    temp->next = temp;
       20:   88:    (*head) = temp;
       20:   89:    return;
        -:   90:  }
        -:   91:  else
        -:   92:  {
        -:   93:    // Insert value before
    43105:   94:    temp->next = (*head)->next;
    43105:   95:    (*head)->next = temp;
    43105:   96:    (*head) = temp;
    43105:   97:    return;
        -:   98:  }
        -:   99:  
        -:  100:}
        -:  101:
        -:  102://***********************************************
        -:  103://
        -:  104:// removal
        -:  105://
        -:  106://***********************************************
        -:  107:
function removeQueue called 43135 returned 100% blocks executed 100%
    43135:  108:itemQ_t* removeQueue(QUEUE_t* userQ)
        -:  109:{
        -:  110:  // Find head
    43135:  111:  itemQ_t **head = &userQ->head;
        -:  112:  
    43135:  113:  itemQ_t* rmvPtr = NULL;
        -:  114:  
        -:  115:  // FIRST check if list is empty
    43135:  116:  if((*head) == NULL)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  117:  {
        -:  118:    // List is already empty
        -:  119:#ifdef DEBUG
        -:  120:    printf("Queue empty");
        -:  121:#endif
       10:  122:    return NULL; 
        -:  123:  }
        -:  124:  // else
        -:  125:  // Remove from list
    43125:  126:  rmvPtr = (*head)->next;
    43125:  127:  if((*head)->next == (*head)) (*head) = NULL;
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
    43105:  128:  else (*head)->next = (*head)->next->next;
        -:  129:  
    43125:  130:  userQ->size--;
        -:  131:  
        -:  132:  
        -:  133:  // return the value to main
    43125:  134:  return rmvPtr;
        -:  135:
        -:  136:}
        -:  137:
function clearQueue called 0 returned 0% blocks executed 0%
    #####:  138:void clearQueue(QUEUE_t* userQ)
        -:  139:{
        -:  140:  // Find head
    #####:  141:  itemQ_t **head = &userQ->head;
        -:  142:  
    #####:  143:  itemQ_t* rmvPtr = NULL;
        -:  144:  
    #####:  145:  while((*head) != NULL)
branch  0 never executed
branch  1 never executed
        -:  146:  {
        -:  147:    // else
        -:  148:    // Remove from list
    #####:  149:    rmvPtr = (*head)->next;
    #####:  150:    if((*head)->next == (*head)) (*head) = NULL;
branch  0 never executed
branch  1 never executed
    #####:  151:    else (*head)->next = (*head)->next->next;
        -:  152:    
        -:  153:    // return the memory to OS
    #####:  154:    free(rmvPtr);
        -:  155:  }
        -:  156:  
        -:  157:  // Check if list is empty
    #####:  158:  if((*head) == NULL)
branch  0 never executed
branch  1 never executed
        -:  159:  {
        -:  160:    // List is already empty
        -:  161:#ifdef DEBUG
        -:  162:    printf("Queue empty.\n"); 
        -:  163:#endif
    #####:  164:    userQ->size = 0;
        -:  165:  }
    #####:  166:}
