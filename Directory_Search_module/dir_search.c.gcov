        -:    0:Source:/home/christian/Documents/GitHub/Cryptography/Directory_Search_module/dir_search.c
        -:    0:Graph:./obj/dir_search.gcno
        -:    0:Data:./obj/dir_search.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:#include "dir_search.h"
        -:    2:#include "error_handler.h"
        -:    3:
        -:    4:
        -:    5://*****************************************************************************
        -:    6://
        -:    7:// create a subdirectory struct
        -:    8://
        -:    9://*****************************************************************************
        -:   10:
function createDirectory called 3306 returned 100% blocks executed 60%
     3306:   11:subDir_t* createDirectory(const char* path, STACK_t* files)
        -:   12:{
     3306:   13:	subDir_t* newDir = malloc(sizeof(subDir_t*));
     3306:   14:	ERROR_PTR_PTR(newDir);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     3306:   15:	newDir->path = path;
     3306:   16:	newDir->files = files;
        -:   17:	
     3306:   18:	return newDir;
        -:   19:}
        -:   20:
        -:   21://*****************************************************************************
        -:   22://
        -:   23:// search a directory and append files to known path, subdirs to search in a queue
        -:   24://
        -:   25://*****************************************************************************
function searchDirectory called 3307 returned 100% blocks executed 84%
     3307:   26:void* searchDirectory(void* dirStruct)
        -:   27:{
        -:   28:	// Directory to search
     3307:   29:	mainDir_t* holdDirs = (mainDir_t*) dirStruct;
        -:   30:	// Extrapulate the necessary information
     3307:   31:	const char* path = holdDirs->path;
     3307:   32:	QUEUE_t* dirQueue = holdDirs->subDirQ;
     3307:   33:	QUEUE_t* directories = holdDirs->baseDir;
        -:   34:	// clear and redo to open correctly
     3307:   35:	char openDir[PATH_MAX] = "";
        -:   36:	// Sorry, disobeying const
        -:   37:	
     3307:   38:	if(strcmp(path, "./") == 0) strcpy((char *) path, "");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     3307:   39:	sprintf(openDir, "./%s", path);
        -:   40:	
        -:   41:	// Create streams and structs and vars and whatnots
        -:   42:  DIR *dp;
        -:   43:  struct dirent *ep;
        -:   44:	struct stat sb;
     3307:   45:	STACK_t* fileStack = malloc(sizeof(STACK_t*));
     3307:   46:	ERROR_PTR_PTR(fileStack);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   47:
        -:   48:	// Use built-in function to properly initialize the structure
     3307:   49:	ERROR_BOOL_PTR(stack_init(fileStack));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:   50:	
        -:   51:	// Open directory
     3307:   52:  dp = opendir ((const char*) openDir);
call    0 returned 100%
     3307:   53:  if (dp != NULL)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   54:	{
    51901:   55:		while ((ep = readdir (dp)))
call    0 returned 100%
branch  1 taken 93%
branch  2 taken 7% (fallthrough)
        -:   56:		{
    45288:   57:			if(holdDirs->verbose) colorReset();	
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
call    2 returned 100%
        -:   58:			// If it isn't . or .. we have a valid directory to mark
    45288:   59:			if(ep->d_name[0] != '.')
branch  0 taken 85% (fallthrough)
branch  1 taken 15%
        -:   60:			{
        -:   61:				// initialize you fool!
    38614:   62:				char* dirName = (char *) calloc(1, sizeof(char)*PATH_MAX);
        -:   63:				// Check if we are in main directory or a sub-directory
    38614:   64:				if(!strcmp(path, "")) sprintf(dirName, "%s", ep->d_name);
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
    38596:   65:				else sprintf(dirName, "%s/%s", path, ep->d_name);
        -:   66:				
        -:   67:				// Now check if it is a folder or a file
    38614:   68:				int returnCode = stat(dirName, &sb);
call    0 returned 100%
    38614:   69:				PERROR_NUM_PTR(returnCode);
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
call    2 returned 100%
        -:   70:				
    38613:   71:				if (returnCode == 0 && S_ISDIR(sb.st_mode))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 9% (fallthrough)
branch  3 taken 91%
        -:   72:				{
        -:   73:					// We have a directory
     3304:   74:					if(holdDirs->verbose) dirPrint(dirName);
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
call    2 returned 100%
     3304:   75:					insertQueue(dirQueue, (void*) dirName);
call    0 returned 100%
        -:   76:				}
    35309:   77:				else if (returnCode == 0 && S_ISREG(sb.st_mode))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:   78:				{
        -:   79:					// We have file
        -:   80:					// Check if the file is executable by user
    70618:   81:					if(sb.st_mode & S_IXUSR)
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
        -:   82:					{
      835:   83:						if(holdDirs->verbose) execPrint(dirName);
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
call    2 returned 100%
      835:   84:						free(dirName);
        -:   85:					}
        -:   86:					else 
        -:   87:					{
    34474:   88:						if(holdDirs->verbose) filePrint(dirName);
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
call    2 returned 100%
    34474:   89:						push(fileStack, (void*) dirName);
call    0 returned 100%
        -:   90:					}
        -:   91:				}
    #####:   92:				else free(dirName);
        -:   93:			} // End check directory
     6674:   94:			else if(holdDirs->verbose && (strcmp(ep->d_name, ".") != 0) && (strcmp(ep->d_name, "..") != 0))
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
branch  2 taken 58% (fallthrough)
branch  3 taken 42%
branch  4 taken 28% (fallthrough)
branch  5 taken 72%
        8:   95:				puts(ep->d_name);
call    0 returned 100%
        -:   96:		} // End directory stream
        -:   97:		
        -:   98:
        -:   99:		// close the stream
     3306:  100:		PERROR_NUM_PTR(closedir (dp));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
     3306:  101:		insertQueue(directories, createDirectory(path, fileStack));
call    0 returned 100%
call    1 returned 100%
        -:  102:		// if we enable sub-directory search as well
        -:  103:	}
        -:  104:  else
    #####:  105:    perror(path);
call    0 never executed
        -:  106:
     3306:  107:	if(holdDirs->verbose) colorReset();
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
call    2 returned 100%
        -:  108:	
     3306:  109:	return 0;
        -:  110:}
        -:  111:
        -:  112://*****************************************************************************
        -:  113://
        -:  114:// main search call
        -:  115://
        -:  116://*****************************************************************************
        -:  117:
function search called 7 returned 100% blocks executed 72%
        7:  118:STACK_t* search(const char* path, bool recursive, bool verbose)
        -:  119:{
        -:  120:	// Time evaluations
        -:  121:	struct timeval StartTime, StopTime;
        -:  122:	QUEUE_t* directories;
        -:  123:	QUEUE_t* dirQueue;
        -:  124:	STACK_t* allFiles;
        -:  125:	unsigned int microsecs;
        7:  126:	int fileCount = 0, dirCount = 0;
        -:  127:	
        -:  128:	// initialize the main structure we are using 
        7:  129:	directories = malloc(sizeof(QUEUE_t*));
        7:  130:	ERROR_PTR_PTR(directories);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  131:	
        7:  132:	dirQueue = malloc(sizeof(QUEUE_t*));
        7:  133:	ERROR_PTR_PTR(dirQueue);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  134:	
        7:  135:	allFiles = malloc(sizeof(STACK_t*));
        7:  136:	ERROR_PTR_PTR(allFiles);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  137:	
        -:  138:	// Use built-in function to properly initialize the structure
        7:  139:	ERROR_BOOL_PTR(queue_init(directories));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        7:  140:	ERROR_BOOL_PTR(queue_init(dirQueue));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        7:  141:	ERROR_BOOL_PTR(stack_init(allFiles));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  142:	
        -:  143:	
        -:  144:	
        -:  145:	// Construct a main directory structure
        7:  146:	mainDir_t mainDir = {path, verbose, directories, dirQueue};
        -:  147:	
        -:  148:	// search starts here, start recording
        7:  149:	PERROR_NUM_PTR(gettimeofday(&StartTime, 0));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  150:	
        -:  151:	// SEARCH BLOCK ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        -:  152:	
        7:  153:	searchDirectory((void*) &mainDir);
call    0 returned 100%
        -:  154:	// Go deep if specified
        7:  155:	if(recursive)
branch  0 taken 43% (fallthrough)
branch  1 taken 57%
        -:  156:	{
        3:  157:		itemQ_t* newSearch = removeQueue(dirQueue);
call    0 returned 100%
     3306:  158:		while(newSearch != NULL)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  159:		{
     3300:  160:			mainDir.path = (const char*) (intptr_t) newSearch->keyValue;
     3300:  161:			searchDirectory((void*) &mainDir);
call    0 returned 100%
        -:  162:			
        -:  163:			// Free the path and the subdirectory searched
     3300:  164:			free(newSearch->keyValue);
     3300:  165:			free(newSearch);
     3300:  166:			newSearch = removeQueue(dirQueue);
call    0 returned 100%
        -:  167:		}
        -:  168:	}
        -:  169:	
        -:  170:	// Free the queue
        7:  171:	free(dirQueue);
        -:  172:	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        -:  173:	
        7:  174:	PERROR_NUM_PTR(gettimeofday(&StopTime, 0));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  175:	
        7:  176:	microsecs=((StopTime.tv_sec - StartTime.tv_sec)*1000000);
        7:  177:	dirCount = directories->size;
        -:  178:
        7:  179:  if(StopTime.tv_usec > StartTime.tv_usec)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        7:  180:    microsecs+=(StopTime.tv_usec - StartTime.tv_usec);
        -:  181:  else
    #####:  182:    microsecs-=(StartTime.tv_usec - StopTime.tv_usec);
        -:  183:	
        -:  184:	// Hold some stuff and things to print out entire search
        7:  185:	itemQ_t* someDir = removeQueue(directories);
call    0 returned 100%
     3320:  186:	while(someDir != NULL)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  187:	{
        -:  188:		// Pull out the subDir_t struct
     3306:  189:		subDir_t* temp = (subDir_t*) (intptr_t) someDir->keyValue;
        -:  190:		
     3306:  191:		fileCount += temp->files->size;
     3306:  192:		itemS_t* someFiles = pop(temp->files);
call    0 returned 100%
        -:  193:		
     3306:  194:		if(fileCount > MAX_FILES) 
branch  0 taken 77% (fallthrough)
branch  1 taken 23%
        -:  195:		{
        -:  196:			// Hope this works..
     2558:  197:			fileCount -= temp->files->size + 1;
        -:  198:			// Grab as many files as we can
     2696:  199:			for(int i = MAX_FILES - fileCount; i > 0 && someFiles != NULL; i--)
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
        -:  200:			{
      138:  201:				push(allFiles, someFiles->keyValue);
call    0 returned 100%
      138:  202:				free(someFiles);
      138:  203:				someFiles = pop(temp->files);
call    0 returned 100%
      138:  204:				fileCount++;
        -:  205:			}
        -:  206:			// Destroy the one we just got entirely!
     2558:  207:			free(someFiles->keyValue);
     2558:  208:			free(someFiles);
        -:  209:			// Then destroy the rest of the stack, not using pathLocal since the names
        -:  210:			// are dynamically allocated
     2558:  211:			clearStack(temp->files, false);
call    0 returned 100%
        -:  212:			// Allow the main while loop to continue, we will simply clear all subdirectories
        -:  213:		}
        -:  214:		else 
        -:  215:		{
        -:  216:			// Pull out all individual files
     2608:  217:			while(someFiles != NULL)
branch  0 taken 60%
branch  1 taken 40% (fallthrough)
        -:  218:			{
     1112:  219:				push(allFiles, someFiles->keyValue);
call    0 returned 100%
     1112:  220:				free(someFiles);
     1112:  221:				someFiles = pop(temp->files);
call    0 returned 100%
        -:  222:			}
        -:  223:		}
        -:  224:		
        -:  225:		// Carefully free the stack pointer, the subdirectory pointer, and then
        -:  226:		// the directory in the queue
     3306:  227:		free(temp->files);
     3306:  228:		free(temp);
     3306:  229:		free(someDir);
        -:  230:		// Next subdirectory entry
     3306:  231:		someDir = removeQueue(directories);
call    0 returned 100%
        -:  232:	}
        -:  233:	
        7:  234:	free(directories);
        -:  235:	
        -:  236:	
        7:  237:	printf("\nFound %d files under %d directories in %u microseconds\n",
call    0 returned 100%
        -:  238:				 fileCount, dirCount, microsecs);
        -:  239:		
        7:  240:  return allFiles;
        -:  241:}
