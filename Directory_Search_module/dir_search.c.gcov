        -:    0:Source:/home/anthony/Documents/Classes/Cryptography/Directory_Search_module/dir_search.c
        -:    0:Graph:./obj/dir_search.gcno
        -:    0:Data:./obj/dir_search.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:#include "dir_search.h"
        -:    2:#include "error_handler.h"
        -:    3:
        -:    4:
        -:    5://*****************************************************************************
        -:    6://
        -:    7:// create a subdirectory struct
        -:    8://
        -:    9://*****************************************************************************
        -:   10:
function createDirectory called 4354 returned 100% blocks executed 60%
     4354:   11:subDir_t* createDirectory(const char* path, STACK_t* files)
        -:   12:{
     4354:   13:	subDir_t* newDir = malloc(sizeof(subDir_t*));
     4354:   14:	ERROR_PTR_PTR(newDir);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     4354:   15:	newDir->path = path;
     4354:   16:	newDir->files = files;
        -:   17:	
     4354:   18:	return newDir;
        -:   19:}
        -:   20:
        -:   21://*****************************************************************************
        -:   22://
        -:   23:// search a directory and append files to known path, subdirs to search in a queue
        -:   24://
        -:   25://*****************************************************************************
function searchDirectory called 4355 returned 100% blocks executed 84%
     4355:   26:void* searchDirectory(void* dirStruct)
        -:   27:{
        -:   28:	// Directory to search
     4355:   29:	mainDir_t* holdDirs = (mainDir_t*) dirStruct;
        -:   30:	// Extrapulate the necessary information
     4355:   31:	const char* path = holdDirs->path;
     4355:   32:	QUEUE_t* dirQueue = holdDirs->subDirQ;
     4355:   33:	QUEUE_t* directories = holdDirs->baseDir;
        -:   34:	// clear and redo to open correctly
     4355:   35:	char openDir[NAME_MAX] = "";
        -:   36:	// Sorry, disobeying const
        -:   37:	
     4355:   38:	if(strcmp(path, "./") == 0) strcpy((char *) path, "");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     4355:   39:	sprintf(openDir, "./%s", path);
        -:   40:	
        -:   41:	// Create streams and structs and vars and whatnots
        -:   42:  DIR *dp;
        -:   43:  struct dirent *ep;
        -:   44:	struct stat sb;
     4355:   45:	STACK_t* fileStack = malloc(sizeof(STACK_t*));
     4355:   46:	ERROR_PTR_PTR(fileStack);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   47:
        -:   48:	// Use built-in function to properly initialize the structure
     4355:   49:	ERROR_BOOL_PTR(stack_init(fileStack));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:   50:	
        -:   51:	// Open directory
     4355:   52:  dp = opendir ((const char*) openDir);
call    0 returned 100%
     4355:   53:  if (dp != NULL)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   54:	{
    53404:   55:		while ((ep = readdir (dp)))
call    0 returned 100%
branch  1 taken 91%
branch  2 taken 9% (fallthrough)
        -:   56:		{
    44695:   57:			if(holdDirs->verbose) colorReset();	
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
call    2 returned 100%
        -:   58:			// If it isn't . or .. we have a valid directory to mark
    44695:   59:			if(ep->d_name[0] != '.')
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -:   60:			{
        -:   61:				// initialize you fool!
    35808:   62:				char* dirName = (char *) calloc(1, sizeof(char)*NAME_MAX);
        -:   63:				// Check if we are in main directory or a sub-directory
    35808:   64:				if(!strcmp(path, "")) sprintf(dirName, "%s", ep->d_name);
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
    35790:   65:				else sprintf(dirName, "%s/%s", path, ep->d_name);
        -:   66:				
        -:   67:				// Now check if it is a folder or a file
    35808:   68:				int returnCode = stat(dirName, &sb);
call    0 returned 100%
    35808:   69:				PERROR_NUM_PTR(returnCode);
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
call    2 returned 100%
        -:   70:				
    35807:   71:				if (returnCode == 0 && S_ISDIR(sb.st_mode))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 12% (fallthrough)
branch  3 taken 88%
        -:   72:				{
        -:   73:					// We have a directory
     4352:   74:					if(holdDirs->verbose) dirPrint(dirName);
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
call    2 returned 100%
     4352:   75:					insertQueue(dirQueue, (void*) dirName);
call    0 returned 100%
        -:   76:				}
    31455:   77:				else if (returnCode == 0 && S_ISREG(sb.st_mode))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:   78:				{
        -:   79:					// We have file
        -:   80:					// Check if the file is executable by user
    62910:   81:					if(sb.st_mode & S_IXUSR)
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        -:   82:					{
     1112:   83:						if(holdDirs->verbose) execPrint(dirName);
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
call    2 returned 100%
     1112:   84:						free(dirName);
        -:   85:					}
        -:   86:					else 
        -:   87:					{
    30343:   88:						if(holdDirs->verbose) filePrint(dirName);
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
call    2 returned 100%
    30343:   89:						push(fileStack, (void*) dirName);
call    0 returned 100%
        -:   90:					}
        -:   91:				}
    #####:   92:				else free(dirName);
        -:   93:			} // End check directory
     8887:   94:			else if(holdDirs->verbose && (strcmp(ep->d_name, ".") != 0) && (strcmp(ep->d_name, "..") != 0))
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
branch  2 taken 58% (fallthrough)
branch  3 taken 42%
branch  4 taken 28% (fallthrough)
branch  5 taken 72%
        8:   95:				puts(ep->d_name);
call    0 returned 100%
        -:   96:		} // End directory stream
        -:   97:		
        -:   98:
        -:   99:		// close the stream
     4354:  100:		PERROR_NUM_PTR(closedir (dp));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
     4354:  101:		insertQueue(directories, createDirectory(path, fileStack));
call    0 returned 100%
call    1 returned 100%
        -:  102:		// if we enable sub-directory search as well
        -:  103:	}
        -:  104:  else
    #####:  105:    perror(path);
call    0 never executed
        -:  106:
     4354:  107:	if(holdDirs->verbose) colorReset();
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
call    2 returned 100%
        -:  108:	
     4354:  109:	return 0;
        -:  110:}
        -:  111:
        -:  112://*****************************************************************************
        -:  113://
        -:  114:// main search call
        -:  115://
        -:  116://*****************************************************************************
        -:  117:
function search called 7 returned 100% blocks executed 72%
        7:  118:STACK_t* search(const char* path, bool recursive, bool verbose)
        -:  119:{
        -:  120:	// Time evaluations
        -:  121:	struct timeval StartTime, StopTime;
        -:  122:	QUEUE_t* directories;
        -:  123:	QUEUE_t* dirQueue;
        -:  124:	STACK_t* allFiles;
        -:  125:	unsigned int microsecs;
        7:  126:	int fileCount = 0, dirCount = 0;
        -:  127:	
        -:  128:	// initialize the main structure we are using 
        7:  129:	directories = malloc(sizeof(QUEUE_t*));
        7:  130:	ERROR_PTR_PTR(directories);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  131:	
        7:  132:	dirQueue = malloc(sizeof(QUEUE_t*));
        7:  133:	ERROR_PTR_PTR(dirQueue);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  134:	
        7:  135:	allFiles = malloc(sizeof(STACK_t*));
        7:  136:	ERROR_PTR_PTR(allFiles);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  137:	
        -:  138:	// Use built-in function to properly initialize the structure
        7:  139:	ERROR_BOOL_PTR(queue_init(directories));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        7:  140:	ERROR_BOOL_PTR(queue_init(dirQueue));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        7:  141:	ERROR_BOOL_PTR(stack_init(allFiles));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  142:	
        -:  143:	
        -:  144:	
        -:  145:	// Construct a main directory structure
        7:  146:	mainDir_t mainDir = {path, verbose, directories, dirQueue};
        -:  147:	
        -:  148:	// search starts here, start recording
        7:  149:	PERROR_NUM_PTR(gettimeofday(&StartTime, 0));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  150:	
        -:  151:	// SEARCH BLOCK ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        -:  152:	
        7:  153:	searchDirectory((void*) &mainDir);
call    0 returned 100%
        -:  154:	// Go deep if specified
        7:  155:	if(recursive)
branch  0 taken 43% (fallthrough)
branch  1 taken 57%
        -:  156:	{
        3:  157:		itemQ_t* newSearch = removeQueue(dirQueue);
call    0 returned 100%
     4354:  158:		while(newSearch != NULL)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  159:		{
     4348:  160:			mainDir.path = (const char*) (intptr_t) newSearch->keyValue;
     4348:  161:			searchDirectory((void*) &mainDir);
call    0 returned 100%
        -:  162:			
        -:  163:			// Free the path and the subdirectory searched
     4348:  164:			free(newSearch->keyValue);
     4348:  165:			free(newSearch);
     4348:  166:			newSearch = removeQueue(dirQueue);
call    0 returned 100%
        -:  167:		}
        -:  168:	}
        -:  169:	
        -:  170:	// Free the queue
        7:  171:	free(dirQueue);
        -:  172:	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        -:  173:	
        7:  174:	PERROR_NUM_PTR(gettimeofday(&StopTime, 0));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  175:	
        7:  176:	microsecs=((StopTime.tv_sec - StartTime.tv_sec)*1000000);
        7:  177:	dirCount = directories->size;
        -:  178:
        7:  179:  if(StopTime.tv_usec > StartTime.tv_usec)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        7:  180:    microsecs+=(StopTime.tv_usec - StartTime.tv_usec);
        -:  181:  else
    #####:  182:    microsecs-=(StartTime.tv_usec - StopTime.tv_usec);
        -:  183:	
        -:  184:	// Hold some stuff and things to print out entire search
        7:  185:	itemQ_t* someDir = removeQueue(directories);
call    0 returned 100%
     4368:  186:	while(someDir != NULL)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  187:	{
        -:  188:		// Pull out the subDir_t struct
     4354:  189:		subDir_t* temp = (subDir_t*) (intptr_t) someDir->keyValue;
        -:  190:		
     4354:  191:		fileCount += temp->files->size;
     4354:  192:		itemS_t* someFiles = pop(temp->files);
call    0 returned 100%
        -:  193:		
     4354:  194:		if(fileCount > MAX_FILES) 
branch  0 taken 66% (fallthrough)
branch  1 taken 34%
        -:  195:		{
        -:  196:			// Hope this works..
     2861:  197:			fileCount -= temp->files->size + 1;
        -:  198:			// Grab as many files as we can
     3147:  199:			for(int i = MAX_FILES - fileCount; i > 0 && someFiles != NULL; i--)
branch  0 taken 9% (fallthrough)
branch  1 taken 91%
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
        -:  200:			{
      286:  201:				push(allFiles, someFiles->keyValue);
call    0 returned 100%
      286:  202:				free(someFiles);
      286:  203:				someFiles = pop(temp->files);
call    0 returned 100%
      286:  204:				fileCount++;
        -:  205:			}
        -:  206:			// Destroy the one we just got entirely!
     2861:  207:			free(someFiles->keyValue);
     2861:  208:			free(someFiles);
        -:  209:			// Then destroy the rest of the stack, not using pathLocal since the names
        -:  210:			// are dynamically allocated
     2861:  211:			clearStack(temp->files, false);
call    0 returned 100%
        -:  212:			// Allow the main while loop to continue, we will simply clear all subdirectories
        -:  213:		}
        -:  214:		else 
        -:  215:		{
        -:  216:			// Pull out all individual files
    12982:  217:			while(someFiles != NULL)
branch  0 taken 87%
branch  1 taken 13% (fallthrough)
        -:  218:			{
     9996:  219:				push(allFiles, someFiles->keyValue);
call    0 returned 100%
     9996:  220:				free(someFiles);
     9996:  221:				someFiles = pop(temp->files);
call    0 returned 100%
        -:  222:			}
        -:  223:		}
        -:  224:		
        -:  225:		// Carefully free the stack pointer, the subdirectory pointer, and then
        -:  226:		// the directory in the queue
     4354:  227:		free(temp->files);
     4354:  228:		free(temp);
     4354:  229:		free(someDir);
        -:  230:		// Next subdirectory entry
     4354:  231:		someDir = removeQueue(directories);
call    0 returned 100%
        -:  232:	}
        -:  233:	
        7:  234:	free(directories);
        -:  235:	
        -:  236:	
        7:  237:	printf("\nFound %d files under %d directories in %u microseconds\n",
call    0 returned 100%
        -:  238:				 fileCount, dirCount, microsecs);
        -:  239:		
        7:  240:  return allFiles;
        -:  241:}
