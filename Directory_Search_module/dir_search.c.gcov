        -:    0:Source:/home/christian/Documents/GitHub/Cryptography/Directory_Search_module/dir_search.c
        -:    0:Graph:./obj/dir_search.gcno
        -:    0:Data:./obj/dir_search.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dir_search.h"
        -:    2:#include "error_handler.h"
        -:    3:
        -:    4:
        -:    5://*****************************************************************************
        -:    6://
        -:    7:// create a subdirectory struct
        -:    8://
        -:    9://*****************************************************************************
        -:   10:
function createDirectory called 1 returned 100% blocks executed 60%
        1:   11:subDir_t* createDirectory(const char* path, STACK_t* files)
        -:   12:{
        1:   13:	subDir_t* newDir = malloc(sizeof(subDir_t*));
        1:   14:	ERROR_PTR_PTR(newDir);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        1:   15:	newDir->path = path;
        1:   16:	newDir->files = files;
        -:   17:	
        1:   18:	return newDir;
        -:   19:}
        -:   20:
        -:   21://*****************************************************************************
        -:   22://
        -:   23:// search a directory and append files to known path, subdirs to search in a queue
        -:   24://
        -:   25://*****************************************************************************
function searchDirectory called 2 returned 100% blocks executed 46%
        2:   26:void* searchDirectory(void* dirStruct)
        -:   27:{
        -:   28:	// Directory to search
        2:   29:	mainDir_t* holdDirs = (mainDir_t*) dirStruct;
        -:   30:	// Extrapulate the necessary information
        2:   31:	const char* path = holdDirs->path;
        2:   32:	QUEUE_t* dirQueue = holdDirs->subDirQ;
        2:   33:	QUEUE_t* directories = holdDirs->baseDir;
        -:   34:	// clear and redo to open correctly
        2:   35:	char openDir[NAME_MAX] = "";
        -:   36:	// Sorry, disobeying const
        -:   37:	
        2:   38:	if(strcmp(path, "./") == 0) strcpy((char *) path, "");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        2:   39:	sprintf(openDir, "./%s", path);
        -:   40:	
        -:   41:	// Create streams and structs and vars and whatnots
        -:   42:  DIR *dp;
        -:   43:  struct dirent *ep;
        -:   44:	struct stat sb;
        2:   45:	STACK_t* fileStack = malloc(sizeof(STACK_t*));
        2:   46:	ERROR_PTR_PTR(fileStack);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   47:
        -:   48:	// Use built-in function to properly initialize the structure
        2:   49:	ERROR_BOOL_PTR(stack_init(fileStack));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:   50:	
        -:   51:	// Open directory
        2:   52:  dp = opendir ((const char*) openDir);
call    0 returned 100%
        2:   53:  if (dp != NULL)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   54:	{
        7:   55:		while ((ep = readdir (dp)))
call    0 returned 100%
branch  1 taken 80%
branch  2 taken 20% (fallthrough)
        -:   56:		{
        4:   57:			if(holdDirs->verbose) colorReset();	
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   58:			// If it isn't . or .. we have a valid directory to mark
        4:   59:			if(ep->d_name[0] != '.')
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        -:   60:			{
        -:   61:				// initialize you fool!
        1:   62:				char* dirName = (char *) calloc(1, sizeof(char)*NAME_MAX);
        -:   63:				// Check if we are in main directory or a sub-directory
        1:   64:				if(!strcmp(path, "")) sprintf(dirName, "%s", ep->d_name);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        1:   65:				else sprintf(dirName, "%s/%s", path, ep->d_name);
        -:   66:				
        -:   67:				// Now check if it is a folder or a file
        1:   68:				int returnCode = stat(dirName, &sb);
call    0 returned 100%
        1:   69:				PERROR_NUM_PTR(returnCode);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:   70:				
    #####:   71:				if (returnCode == 0 && S_ISDIR(sb.st_mode))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   72:				{
        -:   73:					// We have a directory
    #####:   74:					if(holdDirs->verbose) dirPrint(dirName);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   75:					insertQueue(dirQueue, (void*) dirName);
call    0 never executed
        -:   76:				}
    #####:   77:				else if (returnCode == 0 && S_ISREG(sb.st_mode))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   78:				{
        -:   79:					// We have file
        -:   80:					// Check if the file is executable by user
    #####:   81:					if(sb.st_mode & S_IXUSR)
branch  0 never executed
branch  1 never executed
        -:   82:					{
    #####:   83:						if(holdDirs->verbose) execPrint(dirName);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   84:						free(dirName);
        -:   85:					}
        -:   86:					else 
        -:   87:					{
    #####:   88:						if(holdDirs->verbose) filePrint(dirName);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   89:						push(fileStack, (void*) dirName);
call    0 never executed
        -:   90:					}
        -:   91:				}
    #####:   92:				else free(dirName);
        -:   93:			} // End check directory
        3:   94:			else if(holdDirs->verbose && (strcmp(ep->d_name, ".") != 0) && (strcmp(ep->d_name, "..") != 0))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   95:				puts(ep->d_name);
call    0 never executed
        -:   96:		} // End directory stream
        -:   97:		
        -:   98:
        -:   99:		// close the stream
        1:  100:		PERROR_NUM_PTR(closedir (dp));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        1:  101:		insertQueue(directories, createDirectory(path, fileStack));
call    0 returned 100%
call    1 returned 100%
        -:  102:		// if we enable sub-directory search as well
        -:  103:	}
        -:  104:  else
    #####:  105:    perror(path);
call    0 never executed
        -:  106:
        1:  107:	if(holdDirs->verbose) colorReset();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  108:	
        1:  109:	return 0;
        -:  110:}
        -:  111:
        -:  112://*****************************************************************************
        -:  113://
        -:  114:// main search call
        -:  115://
        -:  116://*****************************************************************************
        -:  117:
function search called 2 returned 100% blocks executed 48%
        2:  118:STACK_t* search(const char* path, bool recursive, bool verbose)
        -:  119:{
        -:  120:	// Time evaluations
        -:  121:	struct timeval StartTime, StopTime;
        -:  122:	QUEUE_t* directories;
        -:  123:	QUEUE_t* dirQueue;
        -:  124:	STACK_t* allFiles;
        -:  125:	unsigned int microsecs;
        2:  126:	int fileCount = 0, dirCount = 0;
        -:  127:	
        -:  128:	// initialize the main structure we are using 
        2:  129:	directories = malloc(sizeof(QUEUE_t*));
        2:  130:	ERROR_PTR_PTR(directories);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  131:	
        2:  132:	dirQueue = malloc(sizeof(QUEUE_t*));
        2:  133:	ERROR_PTR_PTR(dirQueue);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  134:	
        2:  135:	allFiles = malloc(sizeof(STACK_t*));
        2:  136:	ERROR_PTR_PTR(allFiles);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  137:	
        -:  138:	// Use built-in function to properly initialize the structure
        2:  139:	ERROR_BOOL_PTR(queue_init(directories));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        2:  140:	ERROR_BOOL_PTR(queue_init(dirQueue));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        2:  141:	ERROR_BOOL_PTR(stack_init(allFiles));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  142:	
        -:  143:	
        -:  144:	
        -:  145:	// Construct a main directory structure
        2:  146:	mainDir_t mainDir = {path, verbose, directories, dirQueue};
        -:  147:	
        -:  148:	// search starts here, start recording
        2:  149:	PERROR_NUM_PTR(gettimeofday(&StartTime, 0));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  150:	
        -:  151:	// SEARCH BLOCK ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        -:  152:	
        2:  153:	searchDirectory((void*) &mainDir);
call    0 returned 100%
        -:  154:	// Go deep if specified
        2:  155:	if(recursive)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  156:	{
    #####:  157:		itemQ_t* newSearch = removeQueue(dirQueue);
call    0 never executed
    #####:  158:		while(newSearch != NULL)
branch  0 never executed
branch  1 never executed
        -:  159:		{
    #####:  160:			mainDir.path = (const char*) (intptr_t) newSearch->keyValue;
    #####:  161:			searchDirectory((void*) &mainDir);
call    0 never executed
        -:  162:			
        -:  163:			// Free the path and the subdirectory searched
    #####:  164:			free(newSearch->keyValue);
    #####:  165:			free(newSearch);
    #####:  166:			newSearch = removeQueue(dirQueue);
call    0 never executed
        -:  167:		}
        -:  168:	}
        -:  169:	
        -:  170:	// Free the queue
        2:  171:	free(dirQueue);
        -:  172:	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        -:  173:	
        2:  174:	PERROR_NUM_PTR(gettimeofday(&StopTime, 0));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  175:	
        2:  176:	microsecs=((StopTime.tv_sec - StartTime.tv_sec)*1000000);
        2:  177:	dirCount = directories->size;
        -:  178:
        2:  179:  if(StopTime.tv_usec > StartTime.tv_usec)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2:  180:    microsecs+=(StopTime.tv_usec - StartTime.tv_usec);
        -:  181:  else
    #####:  182:    microsecs-=(StartTime.tv_usec - StopTime.tv_usec);
        -:  183:	
        -:  184:	// Hold some stuff and things to print out entire search
        2:  185:	itemQ_t* someDir = removeQueue(directories);
call    0 returned 100%
        5:  186:	while(someDir != NULL)
branch  0 taken 33%
branch  1 taken 67% (fallthrough)
        -:  187:	{
        -:  188:		// Pull out the subDir_t struct
        1:  189:		subDir_t* temp = (subDir_t*) (intptr_t) someDir->keyValue;
        -:  190:		
        1:  191:		fileCount += temp->files->size;
        1:  192:		itemS_t* someFiles = pop(temp->files);
call    0 returned 100%
        -:  193:		
        1:  194:		if(fileCount > MAX_FILES) 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  195:		{
        -:  196:			// Hope this works..
    #####:  197:			fileCount -= temp->files->size + 1;
        -:  198:			// Grab as many files as we can
    #####:  199:			for(int i = MAX_FILES - fileCount; i > 0 && someFiles != NULL; i--)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  200:			{
    #####:  201:				push(allFiles, someFiles->keyValue);
call    0 never executed
    #####:  202:				free(someFiles);
    #####:  203:				someFiles = pop(temp->files);
call    0 never executed
    #####:  204:				fileCount++;
        -:  205:			}
        -:  206:			// Destroy the one we just got entirely!
    #####:  207:			free(someFiles->keyValue);
    #####:  208:			free(someFiles);
        -:  209:			// Then destroy the rest of the stack, not using pathLocal since the names
        -:  210:			// are dynamically allocated
    #####:  211:			clearStack(temp->files, false);
call    0 never executed
        -:  212:			// Allow the main while loop to continue, we will simply clear all subdirectories
        -:  213:		}
        -:  214:		else 
        -:  215:		{
        -:  216:			// Pull out all individual files
        2:  217:			while(someFiles != NULL)
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
        -:  218:			{
    #####:  219:				push(allFiles, someFiles->keyValue);
call    0 never executed
    #####:  220:				free(someFiles);
    #####:  221:				someFiles = pop(temp->files);
call    0 never executed
        -:  222:			}
        -:  223:		}
        -:  224:		
        -:  225:		// Carefully free the stack pointer, the subdirectory pointer, and then
        -:  226:		// the directory in the queue
        1:  227:		free(temp->files);
        1:  228:		free(temp);
        1:  229:		free(someDir);
        -:  230:		// Next subdirectory entry
        1:  231:		someDir = removeQueue(directories);
call    0 returned 100%
        -:  232:	}
        -:  233:	
        2:  234:	free(directories);
        -:  235:	
        -:  236:	
        2:  237:	printf("\nFound %d files under %d directories in %u microseconds\n",
call    0 returned 100%
        -:  238:				 fileCount, dirCount, microsecs);
        -:  239:		
        2:  240:  return allFiles;
        -:  241:}
