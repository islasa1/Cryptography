        -:    0:Source:/home/christian/Documents/GitHub/Cryptography/login_module/login.c
        -:    0:Graph:./obj/login.gcno
        -:    0:Data:./obj/login.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:// Anthony Islas
        -:    2:// Date Written: 12 Dec 2014
        -:    3:// Last Revised:  6 Sept 2015
        -:    4:// DESCRIPTION:	This will be the base for logging into a shell that will
        -:    5:// not only exexcute standard UNIX commands, but act as a front end
        -:    6:// to enable encryption of files
        -:    7:
        -:    8:#include <stdio.h>
        -:    9:#include <stdlib.h>
        -:   10:#include <string.h>
        -:   11:#include <stdbool.h>
        -:   12:#include <pwd.h>
        -:   13:#include <time.h>
        -:   14:#include <limits.h>
        -:   15:#include <unistd.h>
        -:   16:
        -:   17:#define _GNU_SOURCE   
        -:   18:#include <crypt.h>
        -:   19:
        -:   20:#include "login.h"
        -:   21:
        -:   22:// Global
        -:   23:static int current_user = -1, max_users = 0;
        -:   24:static char passphraseFile[PATH_MAX];
        -:   25:static char curName[MAX_NAME] = "default";
        -:   26:
function loginProtocol called 0 returned 0% blocks executed 0%
    #####:   27:bool loginProtocol(char option)
        -:   28:{
        -:   29:  // Initialization
    #####:   30:  bool enter_sp = false;
        -:   31:  users_t session_users[MAX_USERS];
        -:   32:	
        -:   33:	FILE* passphrase;
        -:   34:  
    #####:   35:	if((passphrase = fopen(passphraseFile, "r+")) == NULL)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   36:	{
    #####:   37:		printf("File not found. Creating new file\n");
call    0 never executed
    #####:   38:		if((passphrase = fopen(passphraseFile, "w+")) == NULL)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   39:		{
    #####:   40:			printf("Could not create file\n");
call    0 never executed
    #####:   41:			return false;
        -:   42:		}
    #####:   43:		if(option != 'n') 
branch  0 never executed
branch  1 never executed
        -:   44:		{
    #####:   45:		  option = 'n';
    #####:   46:		  printf("Defaulting to make new user...\n");
call    0 never executed
        -:   47:		}
        -:   48:	}
        -:   49:  
        -:   50:  // Defaults for users set first
    #####:   51:  for(int iterator = MAX_USERS; iterator > 0; iterator--)
branch  0 never executed
branch  1 never executed
        -:   52:  {
    #####:   53:    INIT_USER(session_users[iterator - 1]);
        -:   54:  }
        -:   55:  
        -:   56:	// Read in users from file
    #####:   57:	PERROR_NUM_BOOL(fseek(passphrase, 0, SEEK_SET));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   58:	max_users = fread((unsigned char*) session_users, sizeof(unsigned char), sizeof(users_t)*MAX_USERS, passphrase) / (sizeof(users_t));
call    0 never executed
    #####:   59:	if(ferror(passphrase)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   60:		printf("loginProtocol: error reading passphrase file\n");
call    0 never executed
    #####:   61:		return false;
        -:   62:	}
    #####:   63:	PERROR_NUM_BOOL(fclose(passphrase));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:   64:	// Makes sure users are only in memory
        -:   65:    
    #####:   66:  switch(option)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   67:  {
        -:   68:    case 'l':
    #####:   69:      enter_sp = login(session_users);
call    0 never executed
    #####:   70:      break;
        -:   71:    case 'n':
    #####:   72:      enter_sp = newAccount(session_users);
call    0 never executed
    #####:   73:      break;
        -:   74:    case 'd':
    #####:   75:      enter_sp = deleteUser(session_users);
call    0 never executed
    #####:   76:      break;
        -:   77:    default:
    #####:   78:      enter_sp = false;
    #####:   79:      printf("Oops. Looks like the option you requested wasn't found. Try again.\n");
call    0 never executed
    #####:   80:      break;
        -:   81:  }
        -:   82:
    #####:   83:  return enter_sp;  
        -:   84:}
        -:   85:
        -:   86://************************************************************************
        -:   87://
        -:   88:// Taken directly from minishell.c - emulate reading of CLI
        -:   89:// 
        -:   90://************************************************************************
        -:   91:
function readInput called 0 returned 0% blocks executed 0%
    #####:   92:void readInput(char *buffer) 
        -:   93:{
        -:   94:    // original dangerous stdio call - can over-run buffer, see man gets
        -:   95:    // gets(buffer); 
        -:   96:
        -:   97:  
        -:   98:    // suggested safer replacement call - can't go beyond length provided,
        -:   99:    // but we must strip off the line feed included in the buffer unlike gets
        -:  100:    // 
    #####:  101:    ERROR_PTR_VOID(fgets(buffer, MAX_NAME, stdin));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  102:
    #####:  103:    buffer[strlen(buffer) - 1] = '\0';  // overwrite the line feed with null term
        -:  104:}
        -:  105:
        -:  106://************************************************************************
        -:  107://
        -:  108:// Modified readInput to allow getpass to be used instead of stdin
        -:  109:// 
        -:  110://************************************************************************
        -:  111:
function readPasswd called 0 returned 0% blocks executed 0%
    #####:  112:void readPasswd(char *buffer, const char *salt, char *username) 
        -:  113:{
    #####:  114:  char passwdPrompt[] = "Password [4-8 chars]: ";
    #####:  115:  char* ps_buffer = getpass(passwdPrompt);
call    0 never executed
    #####:  116:  int strLen = strlen(ps_buffer);
    #####:  117:  if(strLen < MAX_PASSWD - 5 && strLen >= MIN_INPUT  && (strcmp(username, ps_buffer) != 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  118:  {
    #####:  119:    ps_buffer = crypt(ps_buffer, salt);
call    0 never executed
    #####:  120:    if(ps_buffer == NULL)
branch  0 never executed
branch  1 never executed
        -:  121:    {
    #####:  122:      buffer[0] = '\0';
    #####:  123:      printf("Error in crypt\n");
call    0 never executed
        -:  124:    }
        -:  125:      
    #####:  126:    buffer[strlen(ps_buffer)-1] = '\0';  // overwrite the line feed with null term
    #####:  127:    strcpy(buffer, ps_buffer);
        -:  128:  }
    #####:  129:  else if(strLen >= MAX_PASSWD - 5)
branch  0 never executed
branch  1 never executed
        -:  130:  {
    #####:  131:    buffer[0] = '\0';
    #####:  132:    printf("Error: Password too long\n"); 
call    0 never executed
        -:  133:  }
    #####:  134:  else if(strLen < MIN_INPUT)
branch  0 never executed
branch  1 never executed
        -:  135:  {
    #####:  136:    buffer[0] = '\0';
    #####:  137:    printf("Error: Password too short\n"); 
call    0 never executed
        -:  138:  }
        -:  139:  else 
        -:  140:  {
    #####:  141:    buffer[0] = '\0';
    #####:  142:    printf("Error: Cannot use username as password\n");
call    0 never executed
        -:  143:  }
    #####:  144:}
        -:  145:
        -:  146://************************************************************************
        -:  147://
        -:  148:// Protocol for login
        -:  149:// 
        -:  150://************************************************************************
        -:  151:
function login called 0 returned 0% blocks executed 0%
    #####:  152:bool login(users_t* cur_list)
        -:  153:{
        -:  154:  // Initialize
        -:  155:  char cl_buffer[MAX_PASSWD];
        -:  156:  
        -:  157:  // Prompt
    #####:  158:  printf("Enter username: ");
call    0 never executed
    #####:  159:  readInput(cl_buffer);
call    0 never executed
        -:  160:  
        -:  161:  // Search first for username
    #####:  162:  for(int iterator = MAX_USERS; iterator > 0; iterator--)
branch  0 never executed
branch  1 never executed
        -:  163:  {
        -:  164:    // If successful ask for password
    #####:  165:    if(strcmp(cur_list[MAX_USERS - iterator].user_name,cl_buffer) == 0)
branch  0 never executed
branch  1 never executed
        -:  166:    {
        -:  167:      // prompt 
        -:  168:
    #####:  169:      readPasswd(cl_buffer, cur_list[MAX_USERS - iterator].user_passwd, cur_list[MAX_USERS - iterator].user_name);
call    0 never executed
        -:  170:      // Check password to user account
    #####:  171:      if(strcmp(cur_list[MAX_USERS - iterator].user_passwd,cl_buffer) == 0) 
branch  0 never executed
branch  1 never executed
        -:  172:      {
    #####:  173:        current_user = MAX_USERS - iterator;
    #####:  174:        printf("Logged in as: %s", cur_list[MAX_USERS - iterator].user_name);
call    0 never executed
    #####:  175:        strcpy(curName, cur_list[MAX_USERS - iterator].user_name);
    #####:  176:        current_user == 0 ? printf(" [ADMIN]\n") : printf("\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  177:        return true;
        -:  178:      }
        -:  179:      else
        -:  180:      {
        -:  181:        // Wrong password
    #####:  182:        int err_login = 0;
    #####:  183:        while(err_login < TRIES)
branch  0 never executed
branch  1 never executed
        -:  184:        {
        -:  185:          // Loop allows for a retry 3 times
    #####:  186:          printf("Sorry, try again.\n");
call    0 never executed
    #####:  187:          readPasswd(cl_buffer, cur_list[MAX_USERS - iterator].user_passwd, cur_list[MAX_USERS - iterator].user_name);
call    0 never executed
        -:  188:          // Auto exit if correct
    #####:  189:          if(strcmp(cur_list[MAX_USERS - iterator].user_passwd,cl_buffer) == 0)
branch  0 never executed
branch  1 never executed
        -:  190:          {
    #####:  191:            current_user = MAX_USERS - iterator;
    #####:  192:            printf("Logged in as: %s", cur_list[MAX_USERS - iterator].user_name);
call    0 never executed
    #####:  193:            strcpy(curName, cur_list[MAX_USERS - iterator].user_name);
    #####:  194:            current_user == 0 ? printf(" [ADMIN]\n") : printf("\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  195:            return true;
        -:  196:          }
    #####:  197:          err_login++;
        -:  198:        }
        -:  199:        // If not exited by now, return false - failed login
    #####:  200:        printf("Error: Login fail.\n");
call    0 never executed
    #####:  201:        return false;
        -:  202:      }
        -:  203:    }
        -:  204:    // Continue through list
        -:  205:  } // End search
        -:  206:  // Search unsuccessful
    #####:  207:  printf("Error: Oops. Username not found. Login fail.\n");
call    0 never executed
    #####:  208:  return false;
        -:  209:}
        -:  210:
        -:  211://************************************************************************
        -:  212://
        -:  213:// Protocol for creating a new account (currently just for session
        -:  214://
        -:  215://************************************************************************
        -:  216:
function newAccount called 0 returned 0% blocks executed 0%
    #####:  217:bool newAccount(users_t* cur_list)
        -:  218:{
        -:  219:  //
        -:  220:  // Create new session account
        -:  221:  //
        -:  222:  
        -:  223:  // Initialize
        -:  224:  char cl_buffer[MAX_NAME];
    #####:  225:  int temp_user = current_user;
        -:  226:	
        -:  227:	FILE* passphrase;
    #####:  228:	if((passphrase = fopen(passphraseFile, "r+")) == NULL)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  229:	{
    #####:  230:		printf("File not found.\n");
call    0 never executed
    #####:  231:		return false;
        -:  232:	}
        -:  233:	// Makes sure users are only in memory
        -:  234:  
        -:  235:  // Search first for username spot available
    #####:  236:  for(int iterator = MAX_USERS; iterator > 0; iterator--)
branch  0 never executed
branch  1 never executed
        -:  237:  {
        -:  238:    // If successful create account
    #####:  239:    if(strcmp(cur_list[MAX_USERS - iterator].user_name, DEF_CHAR) == 0)
branch  0 never executed
branch  1 never executed
        -:  240:    {
    #####:  241:      current_user = MAX_USERS - iterator;
    #####:  242:      break;
        -:  243:    }
        -:  244:  } // search end
        -:  245:  // If successful, current_user should have changed
    #####:  246:  if(temp_user == current_user)  // No available spot
branch  0 never executed
branch  1 never executed
        -:  247:  {
    #####:  248:    printf("Error: No spot available to create account. Please contact:\n\tAdmin: USER[0] to get account\n");
call    0 never executed
        -:  249:    // TODO Implement admin priveleges and deletion of accounts
    #####:  250:    PERROR_NUM_BOOL(fclose(passphrase));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  251:    return false;
        -:  252:  }
        -:  253:  
        -:  254:  // ELSE make account
    #####:  255:  printf("Creating a new Account for USER[%d]:\n", current_user);
call    0 never executed
        -:  256:  // Prompt
        -:  257:  
    #####:  258:  printf("Username[%d-%d chars]: ", MIN_INPUT, MAX_NAME - 1);
call    0 never executed
    #####:  259:  readInput(cl_buffer);
call    0 never executed
    #####:  260:  printf("\tUsername: %s\n", cl_buffer);
call    0 never executed
    #####:  261:  int nameSize = strlen(cl_buffer);
    #####:  262:  if((nameSize < MAX_NAME - 1) && nameSize >= MIN_INPUT)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  263:  {
        -:  264:    // Search if username already taken
    #####:  265:    for(int iterator = MAX_USERS; iterator > 0; iterator--)
branch  0 never executed
branch  1 never executed
        -:  266:    {
        -:  267:      // If successful create account
    #####:  268:      if(strcmp(cur_list[MAX_USERS - iterator].user_name, cl_buffer) == 0)
branch  0 never executed
branch  1 never executed
        -:  269:      {
    #####:  270:        printf("Error: Username not available\n");
call    0 never executed
    #####:  271:        current_user = temp_user;
    #####:  272:        PERROR_NUM_BOOL(fclose(passphrase));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  273:        return false;
        -:  274:      }
        -:  275:    } // search end
    #####:  276:    strcpy(cur_list[current_user].user_name, cl_buffer);
    #####:  277:    strcpy(curName, cur_list[current_user].user_name);
        -:  278:  }
    #####:  279:  else if(nameSize >= MAX_NAME)
branch  0 never executed
branch  1 never executed
        -:  280:  {
    #####:  281:    printf("Error: Username too long\n");
call    0 never executed
    #####:  282:    current_user = temp_user;
    #####:  283:    PERROR_NUM_BOOL(fclose(passphrase));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  284:	current_user = temp_user;
    #####:  285:    return false;
        -:  286:  }
    #####:  287:  else if(nameSize < MIN_INPUT)
branch  0 never executed
branch  1 never executed
        -:  288:  {
    #####:  289:    printf("Error: Username too short\n");
call    0 never executed
    #####:  290:    current_user = temp_user;
    #####:  291:    PERROR_NUM_BOOL(fclose(passphrase));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  292:	current_user = temp_user;
    #####:  293:    return false;
        -:  294:  }
        -:  295:  
        -:  296:  // Set password
        -:  297:  // Seed rand with user's first letter and its length
        -:  298:  // then assign salt
    #####:  299:  srand(((unsigned int) cur_list[current_user].user_name[0] + strlen(cur_list[current_user].user_name)));
call    0 never executed
    #####:  300:  const char salt[3] = {rand() % 26 + ASCII_A, rand() % 26 + ASCII_A, '\0'};
call    0 never executed
call    1 never executed
    #####:  301:  readPasswd(cl_buffer, salt, cur_list[current_user].user_name);
call    0 never executed
        -:  302:  
    #####:  303:  if(cl_buffer[0] != '\0')
branch  0 never executed
branch  1 never executed
        -:  304:  {
    #####:  305:    strcpy(cur_list[current_user].user_passwd, cl_buffer);
    #####:  306:		cur_list[current_user].user_id = current_user;
        -:  307:		
        -:  308:		// Update PASSPHRASE file
    #####:  309:		PERROR_NUM_BOOL(fseek(passphrase, 0, SEEK_SET));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  310:		fwrite((unsigned char*) cur_list, sizeof(unsigned char), sizeof(users_t)*(current_user + 1), passphrase);
call    0 never executed
    #####:  311:    PERROR_NUM_BOOL(fclose(passphrase));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  312:    printf("Logged in as: %s", cur_list[current_user].user_name);
call    0 never executed
    #####:  313:    current_user == 0 ? printf(" [ADMIN]\n") : printf("\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:  314:    // Makes sure users are only in memory
        -:  315:		
    #####:  316:		return true;
        -:  317:  }
        -:  318:  else 
        -:  319:  {
    #####:  320:    printf("Error: Could not create user. Password error in length or same as username\n");
call    0 never executed
    #####:  321:    INIT_USER(cur_list[current_user]);
    #####:  322:    current_user = temp_user;
    #####:  323:    PERROR_NUM_BOOL(fclose(passphrase));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  324:		return false;
        -:  325:  }
        -:  326:}
        -:  327:
        -:  328:
        -:  329://************************************************************************
        -:  330://
        -:  331:// Protocol for delete user
        -:  332:// 
        -:  333://************************************************************************
        -:  334:// Note: Must be admin USER[0] to use this option!
function deleteUser called 0 returned 0% blocks executed 0%
    #####:  335:bool deleteUser(users_t* cur_list)
        -:  336:{ 
        -:  337:  char cl_buffer[MAX_NAME];
    #####:  338:  if(current_user >= 1)
branch  0 never executed
branch  1 never executed
        -:  339:  {
    #####:  340:    printf("Delete account? [Yn]: ");
call    0 never executed
    #####:  341:    readInput(cl_buffer);
call    0 never executed
    #####:  342:    if(cl_buffer[0] == 'Y' || cl_buffer[0] == 'y')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  343:    {
    #####:  344:      INIT_USER(cur_list[current_user]); 
        -:  345:
        -:  346:      // Update passphrase file
        -:  347:      FILE* passphrase;
    #####:  348:      if((passphrase = fopen(passphraseFile, "r+")) == NULL)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  349:      {
    #####:  350:        printf("File not found.\n");
call    0 never executed
    #####:  351:        return false;
        -:  352:      }
    #####:  353:      PERROR_NUM_BOOL(fseek(passphrase, 0, SEEK_SET));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  354:      fwrite((unsigned char*) cur_list, sizeof(unsigned char), sizeof(users_t)*max_users, passphrase);
call    0 never executed
    #####:  355:      PERROR_NUM_BOOL(fclose(passphrase));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  356:
    #####:  357:      printf("Deleted USER[%d] account.\n", current_user);
call    0 never executed
    #####:  358:      current_user = -1;
    #####:  359:      return true;
        -:  360:    }
    #####:  361:    return false;
        -:  362:  }
    #####:  363:  else if(current_user == 0)
branch  0 never executed
branch  1 never executed
        -:  364:  {
        -:  365:    // Admin user
    #####:  366:    printf("Enter username: ");
call    0 never executed
    #####:  367:    readInput(cl_buffer);
call    0 never executed
        -:  368:
        -:  369:    // Stolen from login protocol
        -:  370:    // Search first for username
    #####:  371:    for(int iterator = MAX_USERS; iterator > 0; iterator--)
branch  0 never executed
branch  1 never executed
        -:  372:    {
        -:  373:      // If successful verify deletion and write out
    #####:  374:      if(strcmp(cur_list[MAX_USERS - iterator].user_name,cl_buffer) == 0)
branch  0 never executed
branch  1 never executed
        -:  375:      {
    #####:  376:        printf("Delete user ""%s""? [Yn]: ", cur_list[MAX_USERS - iterator].user_name);
call    0 never executed
    #####:  377:        readInput(cl_buffer);
call    0 never executed
        -:  378:        // Assume everything else is N
    #####:  379:        if(cl_buffer[0] == 'Y' || cl_buffer[0] == 'y')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  380:        {
    #####:  381:          INIT_USER(cur_list[MAX_USERS - iterator]); 
        -:  382:
        -:  383:          // Update passphrase file
        -:  384:          FILE* passphrase;
    #####:  385:          if((passphrase = fopen(passphraseFile, "r+")) == NULL)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  386:          {
    #####:  387:            printf("File not found.\n");
call    0 never executed
    #####:  388:            return false;
        -:  389:          }
    #####:  390:          PERROR_NUM_BOOL(fseek(passphrase, 0, SEEK_SET));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  391:          fwrite((unsigned char*) cur_list, sizeof(unsigned char), sizeof(users_t)*max_users, passphrase);
call    0 never executed
    #####:  392:          PERROR_NUM_BOOL(fclose(passphrase));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  393:
        -:  394:          // If admin deleted self
    #####:  395:          if((MAX_USERS - iterator) == 0)
branch  0 never executed
branch  1 never executed
        -:  396:          {
    #####:  397:            current_user = -1;
    #####:  398:            printf("Logged admin out\n");
call    0 never executed
        -:  399:          }
        -:  400:
    #####:  401:          printf("Deleted USER[%d] account.\n", MAX_USERS - iterator);
call    0 never executed
    #####:  402:          return true;
        -:  403:        }
    #####:  404:        return false;
        -:  405:      }
        -:  406:      // Continue through list
        -:  407:    } // End search
        -:  408:    // Search unsuccessful
    #####:  409:    printf("Error: Username not found. Delete fail.\n");
call    0 never executed
    #####:  410:    return false;
        -:  411:  }
    #####:  412:  return false;
        -:  413:}
        -:  414:
        -:  415:
        -:  416://************************************************************************
        -:  417://
        -:  418:// Accessors
        -:  419:// 
        -:  420://************************************************************************
function loginGetUsername called 1 returned 100% blocks executed 100%
        1:  421:char* loginGetUsername(void)
        -:  422:{
        1:  423:  return curName;
        -:  424:}
        -:  425:
        -:  426://************************************************************************
        -:  427://
        -:  428:// Initilize the module, fix bug where passphrase file was dependent on 
        -:  429:// working directory of program
        -:  430://
        -:  431://************************************************************************
function LoginModuleInit called 0 returned 0% blocks executed 0%
    #####:  432:bool LoginModuleInit(void)
        -:  433:{
    #####:  434:  uid_t uid = geteuid();
call    0 never executed
    #####:  435:  errno = 0;
call    0 never executed
        -:  436:  
    #####:  437:  struct passwd *pw = getpwuid(uid);
call    0 never executed
        -:  438:  
        -:  439:  // Check if errno has changed
    #####:  440:  PERROR_NUM_BOOL((errno != 0 ? -1 : 0));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  441:  if (pw)
branch  0 never executed
branch  1 never executed
        -:  442:  {
    #####:  443:    sprintf(passphraseFile, "/home/%s/%s", pw->pw_name, PASSPHRASE);
    #####:  444:    return true;
        -:  445:  }
    #####:  446:  else return false;
        -:  447:}
        -:  448:
function loginGetCurUser called 2 returned 100% blocks executed 100%
        2:  449:int loginGetCurUser(void)
        -:  450:{
        2:  451:  return current_user; 
        -:  452:}
        -:  453:
function loginSetCurUser called 2 returned 100% blocks executed 100%
        2:  454:void loginSetCurUser(int newCurUser)
        -:  455:{
        2:  456:  current_user = newCurUser; 
        2:  457:}
